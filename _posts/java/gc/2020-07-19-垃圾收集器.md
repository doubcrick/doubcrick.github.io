---
layout: post
title: 什么是java
category: JAVA
keywords: java
---

### 1、十种垃圾收集器

serial：单线程回收器，复制算法，适合单CPU、低内存环境（几十 M 至一两百 M）

serialOld：适用老年代，标记整理算法

parNew：Serial 收集器的改进多线程版本(其他与serial一样)，目前只有它能与 CMS 收集器配合工

parallelOld：SerialOld 的多线程版本，标记整理，与ParallelScavenge配合作为吞吐量优先选择

parallelScavenge：不可与CMS组合，复制算法，吞吐量优先，吞吐量 = 运行用户代码时间 /(运行用户代码时间 + 垃圾收集时间)

CMS：并发收集，分为四个过程，1 初始标记，2 并发标记，3 重新标记，4 并发清理，并发时占用大量 cpu 资源这是在停顿时间和性能间做出的取舍（CPU换时间）

G1：同时收集新生代老年代，引入分区region弱化分代(逻辑)，可控收集时间，标记-整理；特点：Remembered Set(对象引用的调用信息)不需从根节点遍历、remembered set log(整合并发标记阶段的变化)、优先收集价值最大的 region

ZGC：基于三色指针(colored pointers)，完全无分代；无碎片，时间可控，超大堆

Shenandoah：基于brooks pointers，低暂停时间

Epsilon：（A No-Op Garbage Collector）垃圾回收器控制内存分配，但是不执行任何垃圾回收工作。一旦 java 的堆被耗尽，jvm 就直接关闭。



### 2、垃圾收集器搭配策略

serial GC+old：分代，机器特别老，内存小

parallel GC+old：分代，计算场景

PN+CMS：分代，10个G左右，节省内存（问题：浮动垃圾）

G1：非分代，16G以上，三色标记算法，指定暂停时间，空间换时间，浪费很多内存（不是吞吐量优先，比PN+CMS低10%~15%）；两种回收模式YGC和mixedGC，YGC按以前的回收情况，在5%~60%浮动，所有内存占用堆45%时产生mixed GC混合GC（既包含了YGC也包含类似CMS的并发），

### 3、垃圾收集算法

#### a、标记清除算法

最基础的垃圾收集算法，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成之后统一回收掉所有被标记的对象。

标记-清除算法的**缺点**有两个：首先，**效率问题**，标记和清除效率都不高。其次，标记清除之后会产生大量的不连续的**内存碎片**，空间碎片太多会导致当程序需要为较大对象分配内存时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

#### b、复制算法

将可用内存按容量分成大小相等的两块，每次只使用其中一块，当这块内存使用完了，就将还存活的对象复制到另一块内存上去，然后把使用过的内存空间一次清理掉。这样使得每次都是对其中一块内存进行回收，内存分配时不用考虑内存碎片等复杂情况，只需要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。

复制算法的缺点显而易见，可使用的**内存降为原来一半**。

#### c、标记整理算法

标记-整理算法在标记-清除算法基础上做了改进，标记阶段是相同的标记出所有需要回收的对象，在标记完成之后不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，在移动过程中清理掉可回收的对象，这个过程叫做整理。

标记-整理算法相比标记-清除算法的优点是内存被整理以后不会产生大量不连续内存碎片问题。

复制算法在对象存活率高的情况下就要执行较多的复制操作，效率将会变低，而在对象存活率高的情况下使用标记-整理算法效率会大大提高。

#### d、分代收集算法

根据内存中对象的存活周期不同，将内存划分为几块，java的虚拟机中一般把内存划分为新生代和年老代，当新创建对象时一般在新生代中分配内存空间，当新生代垃圾收集器回收几次之后仍然存活的对象会被移动到年老代内存中，当大对象在新生代中无法找到足够的连续内存时也直接在年老代中创建。

#### e、使用

新生代：survivor（复制和标记-清除垃圾）

年老代：（标记-整理）

永久代（方法区）（标记-整理）

### 4、垃圾判断方法

引用计数法、可达性分析法(GCRoots)

GC roots有哪些？

虚拟机栈局部变量表、方法区静态属性及常量、本地方法栈的JNI；

为什么这么多垃圾收集器？

因为内存在不断扩大

### 5、收集器工作过程

#### a、G1

G1 的工作过程：

初始标记：这个过程跟 CMS 第一个过程差不多，只是标记一下 GC Root 关联的对象。

并发标记：这个过程时间比较久，分析 GC Root 到所有对象的可达性分析。如果从 GC Root 节点开始遍历所有对象会比较耗时，实际上 JVM 也不是这么做的。JVM 是使用 Remembered Set 保存了对象引用的调用信息，在可达性分析的时候只需要同时遍历 remembered set 就好了，不需要从根节点开始挨个遍历。

最终标记：由于并发标记阶段，用户线程仍然在工作，会对标记产生一些偏差，这时候需要通过 remembered set log 来记录这些改变，在这个阶段将改变合并到 remembered set 中。完成最终标记。

筛选清除：通过标记整理的算法，根据用户配置的回收时间，和维护的优先级列表，优先收集价值最大的 region。收集阶段是基于标记 - 整理和复制算法实现

### 6、总结

| 收集器                | 串行、并行 or 并发 | 新生代 / 老年代 | 算法                   | 目标         | 适用场景                                      |
| --------------------- | ------------------ | --------------- | ---------------------- | ------------ | --------------------------------------------- |
| **Serial**            | 串行               | 新生代          | 复制算法               | 响应速度优先 | 单 CPU 环境下的 Client 模式                   |
| **Serial Old**        | 串行               | 老年代          | 标记 - 整理            | 响应速度优先 | 单 CPU 环境下的 Client 模式、CMS 的后备预案   |
| **ParNew**            | 并行               | 新生代          | 复制算法               | 响应速度优先 | 多 CPU 环境时在 Server 模式下与 CMS 配合      |
| **Parallel Scavenge** | 并行               | 新生代          | 复制算法               | 吞吐量优先   | 在后台运算而不需要太多交互的任务              |
| **Parallel Old**      | 并行               | 老年代          | 标记 - 整理            | 吞吐量优先   | 在后台运算而不需要太多交互的任务              |
| **CMS**               | 并发               | 老年代          | 标记 - 清除            | 响应速度优先 | 集中在互联网站或 B/S 系统服务端上的 Java 应用 |
| **G1**                | 并发               | both            | 标记 - 整理 + 复制算法 | 响应速度优先 | 面向服务端应用，将来替换 CMS                  |
| ZGC                   | 并发               | both            | 三色标记算法           | 响应速度优先 | G1的下一代                                    |

