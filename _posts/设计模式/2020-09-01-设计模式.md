---
layout: post
title: 设计模式
category: 设计模式
keywords: 设计模式
---

### 1、设计模式的目的

代码重用性、可读性、可扩展性、可靠性、高内聚低耦合

### 2、七大原则

单一职责原则：一个类只负责一项职责

接口隔离原则：一个类对另一个类的依赖建立在最小的接口上

里氏替换原则：引用基类的地方必须能透明地使用其子类【子类尽量不重写父类的方法】（尽量使用依赖、组合、聚合）

依赖倒转原则：抽象不应该依赖细节，细节依赖抽象

开闭原则(ocp)：扩展开放修改关闭

迪米特法则：最少依赖，一个类对自己依赖的类知道越少越好

合成复用原则：尽量使用合成\聚合而不是继承

### 3、类之间的关系

泛化：继承，依赖关系的特例

实现：实现接口，依赖关系特例

依赖：类中用到了对方就存在依赖 成员变量、方法参数、方法返回值

关联：双向与单向，1表示有且仅有一个，0...表示0个或多个，0,1表示0个或1个，n...m表示n到m个都可以，

组合：整体与部分不可分开，如人与头、身体

聚合：整体和部分可以分开，如显示器、鼠标

### 4、设计模式的分类

##### a、创建型模式（5）

单例、工厂、抽象工厂、建造者、原型

##### b、结构型模式（7）

适配器、桥接、装饰、组合、外观、享元、代理

适配器、桥接、装饰、组合、外观、享元、代理

##### c、行为型模式（11）

模板、状态、访问者、观察者、策略、责任链、命令、迭代器、中介者、备忘录、解释器

### 5、常用的设计模式

##### a、单例

饿汉（静态变量、代码块）：造成内存浪费，可反序列化

懒汉（DCL）：锁机制线程安全延迟加载，可反序列化

内部类：类加载机制保证线程安全延迟加载，可反序列化

枚举：EffectiveJava推荐

JDK应用：runtime

##### b、工厂

简单工厂：工厂类使用ifelse控制创建的实例

工厂方法：定义一个创建对象的抽象方法，子类决定要实例化的类，将对象实例化推迟到子类

抽象工厂：定义接口用于创建相关或有依赖关系的对象簇，将工厂抽象成抽象工厂和具体实现的工厂子类

JDK应用：calendar

##### c、原型

拷贝原型创建新的对象，分为深拷贝（序列化）和浅拷贝（Object.clone）

角色：一个接口定义克隆方法，实现类实现方法克隆自己

spring应用：指定bean的类型为单例或原型，原型类型的bean创建克隆生成新的实例

其他应用：剪贴板、ArrayList中的clone（拷贝数组）

##### d、建造者模式

将复杂对象建造过程抽象出来，使抽象过程的不同实现方法构造出不同表现(属性)的对象。

角色：

1) Product（产品角色）：等待构造的产品对象。
2) Builder（抽象建造者）： 创建一个Product 对象的各个部件指定的接口/抽象类。
3) ConcreteBuilder（具体建造者）： 实现接口，构建和装配各个部件。
4) Director（指挥者）： 构建一个使用Builder 接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作
用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。

JDK应用：stringbuilder

1.Appendable 接口定义了多个append 方法(抽象方法), 即Appendable 为抽象建造者, 定义了抽象方法
2.AbstractStringBuilder 实现了Appendable 接口方法，这里的AbstractStringBuilder 已经是建造者，只是不能
实例化
3.StringBuilder 即充当了指挥者角色，同时充当了具体的建造者，建造方法的实现是由AbstractStringBuilder 完
成, 而StringBuilder 继承了AbstractStringBuilder

##### e、适配器

将原本不兼容的接口融合在一起工作

类适配器：通过继承原类实现目标方法

对象适配器：持有原类引用实现目标方法

接口适配器：设计一个抽象类实现接口每个方法提供一个默认实现（空方法），子类可有选择地覆盖父类的某些方法来实现

SpringMVC应用：HandlerAdapter，spring定义一个适配器接口，每一种controller有一种对应的适配器实现类(isSupport方法)

##### f、桥接

将实现与抽象放在两个不同的类层次中可以独立改变。桥接模式替代多层继承方案，可以减少子类的个数。要求正确识别出系统中两个独立变化的维度(抽象、和实现)。

JDK 日志应用：Handle（memory、socket、stream、xml） 和 Formatter（simple） 类是两个抽象类，它们可以分别独立的变化（有不同的子类）；而 Handle 类中包含对 Formatter 类的引用。Handle 通过 setFormatter 方法可以方便的替换不同的 Formatter 类。

##### g、装饰者

动态的将新功能附加到对象上。

装饰者接收一个被装饰者对象，对其进行加工。装饰者就像打包一个快递主体如衣服，报装如报纸填充、纸板、木板等。

JDK应用：IO流，filterInputStream是抽象装饰者包含被装饰者inputStream，其下子类如bufferInputStream、dataInputStream、lineNumberInputStream。

##### h、组合

创建对象组的树形结构，表示整体与部分的层次关系，使用户对单个对象和组合对象的访问具有一致性。

需要遍历组织机构或者处理的对象具有树形结构适应该模式，如果节点和叶子有很大差异则不适用。

JDK应用：

1.swing组件容器构件（如 Container）和成员构件（如 Checkbox、Button 和 TextComponent 等），他们都是继承、关联自抽象组件类 Component。

2.Map 就是一个抽象构件（同时这个构件中只支持键值对的存储格式），而 HashMap 是一个中间构件，HashMap 中的 Node 节点就是叶子节点。说到中间构件就会有规定的存储方式。HashMap 中的存储方式是一个静态内部类的数组 Node<K,V>[] tab。

##### i、外观

为子系统中的一组接口提供一个一致的界面，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用

##### j、享元

蝇量，运用共享技术有效地支持大量细粒度的对象

内部状态指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变
外部状态指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态。

举个例子：围棋理论上有361 个空位可以放棋子，每盘棋都有可能有两三百个棋子对象产生，因为内存空间有限，一台服务器很难支持更多的玩家玩围棋游戏，如果用享元模式来处理棋子，那么棋子对象就可以减少到只有两个实例，这样就很好的解决了对象的开销问题

应用：String 常量池、integer(小于128)、数据库连接池、缓冲池

##### k、代理

为一个对象提供一个替身，以控制对这个对象的访问。可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能。

静态代理：与代理对象一起实现相同的接口或者是继承相同父类

动态代理：JDK接口代理，newProxyInstance(classloader，interfaces，InvocationHandler)

cglib代理：继承代理类，使用ASM转换字节码生成新的类

其他代理：防火墙代理、缓存代理、远程代理、同步代理

##### l、模板方法

定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤

父类中，我们可以定义一个方法，它默认不做任何事，子类可以视情况要不要覆盖它，该方法称为“钩子”。

一般模板方法都加上final 关键字， 防止子类重写模板方法.

spring应用：abstractApplicationContext通过不同子类实现从注解、xml中读取bean定义

##### m、命令

需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可。使得请求发送者与请求接收者消除彼此之间的耦合。

空命令也是一种设计模式，它为我们省去了判空的操作。

角色：

1) Invoker 是调用者角色
2) Command: 是命令角色，需要执行的所有命令都在这里，可以是接口或抽象类
3) Receiver: 接受者角色，知道如何实施和执行一个请求相关的操作
4) ConcreteCommand: 将一个接受者对象与一个动作绑定，调用接受者相应的操作，实现execute（可以是匿名内部类）

spring应用：jdbctemplate其中execute方法传入StatementCallback的命令实现对结果（是否返回值）的不同处理。

##### n、访问者

封装一些作用于某种数据结构的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。主要将数据结构与数据操作分离，解决数据结构和操作耦合性问题。

工作原理是：在被访问的类里面加一个对外提供接待访问者的接口

应用场景是：需要对一个对象结构中的对象进行很多不同操作(这些操作彼此没有关联)，同时需要避免让这些操作"污染"这些对象的类，可以选用访问者模式解决

角色：

1) Visitor 是抽象访问者，为该对象结构中的ConcreteElement 的每一个类声明一个visit 操作
2) ConcreteVisitor ：是一个具体的访问值实现每个有Visitor 声明的操作，是每个操作实现的部分.
3) ObjectStructure 能枚举它的元素， 可以提供一个高层的接口，用来允许访问者访问元素
4) Element 定义一个accept 方法，接收一个访问者对象
5) ConcreteElement 为具体元素，实现了accept 方法

示例
如果老师教学反馈得分大于等于 85 分、学生成绩大于等于 90 分，则可以入选成绩优秀奖；如果老师论文数目大于 8、学生论文数目大于 2，则可以入选科研优秀奖。在这个例子中，老师和学生就是 Element，他们的数据结构稳定不变。从上面的描述中，我们发现，对数据结构的操作是多变的，一会儿评选成绩，一会儿评选科研，这样就适合使用访问者模式来分离数据结构和操作。

ASM 应用：ClassVisitor、ClassReader、ClassWriter、ClassAdapter、AnnotationVisitor、FieldVisitor、MethodVisitor

1.ClassReader 读取字节码到内存中，生成用于表示该字节码的内部表示的树，ClassReader 对应于访问者模式中的元素
2.组装 ClassVisitor 责任链，这一系列 ClassVisitor 完成了对字节码一系列不同的字节码修改工作，对应于访问者模式中的访问者 Visitor
3.调用 ClassReader#accept () 方法，传入 ClassVisitor 对象，此 ClassVisitor 是责任链的头结点，经过责任链中每一个 ClassVisitor 的对已加载进内存的字节码的树结构上的每个节点的访问和修改
4.在责任链的末端，调用 ClassWriter 这个 visitor 进行修改后的字节码的输出工作

##### o、迭代器

提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示，即：不暴露其内部的结构。

JDK应用：ArrayList，其内部类Itr实现了Iterator接口

##### p、观察者

解决1对多的变化通知问题，发布订阅

JDK应用：1.8中Observable与Observer在1.9弃用（不可序列化、没有线程安全），使用Flow中的Processor，Publisher，Subscriber 和 Subscription一组接口

Flow.Processor ：既充当订户又充当发布者的组件。

Flow.Publisher ：订户收到的项目的生产者。

Flow.Subscriber ：消息的接收者。

Flow.Subscription：链接 a Flow.Publisher 和的消息控件 Flow.Subscriber。

##### q、中介者

一个中介对象来封装一系列的对象交互

角色：

1) Mediator 就是抽象中介者,定义了同事对象到中介者对象的接口
2) Colleague 是抽象同事类
3) ConcreteMediator 具体的中介者对象, 实现抽象方法, 他需要知道所有的具体的同事类,即以一个集合来管理
HashMap,并接受某个同事对象消息，完成相应的任务
4) ConcreteColleague 具体的同事类，会有很多, 每个同事只知道自己的行为， 而不了解其他同事类的行为(方法)，
但是他们都依赖中介者对象

注意：多个类相互耦合，会形成网状结构, 使用中介者模式将网状结构分离为星型结构，进行解耦。中介者承担了较多的责任，一旦中介者出现了问题，整个系统就会受到影响。

应用：MVC 模式，C（Controller 控制器）是M（Model 模型）和V（View 视图）的中介者，在前后端交互时起
到了中间人的作用

##### r、备忘录

在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态

应用场景：1、后悔药。2、打游戏时的存档。3、Windows 里的ctri + z。4、IE 中的后退。4、数
据库的事务管理

##### s、解释器

是指给定一个语言(表达式)，定义它的文法的一种表示，并定义一个解释器，使用该解释器来解释语言中的句子(表达式)

应用场景
-应用可以将一个需要解释执行的语言中的句子表示为一个抽象语法树
-一些重复出现的问题可以用一种简单的语言来表达
-一个简单语法需要解释的场景

例子：编译器、运算表达式计算、正则表达式、机器人等

spring应用：SpelExpressionParser

##### t、状态

对象在多种状态转换时，需要对外输出不同的行为的问题。状态和行为是一一对应的，状态之间可以相互转换

角色：

1) Context 类为环境角色, 用于维护State 实例,这个实例定义当前状态
2) State 是抽象状态角色,定义一个接口封装与Context 的一个特点接口相关行为
3) ConcreteState 具体的状态角色，每个子类实现一个与Context 的一个状态相关行为

##### u、策略

定义算法族（策略组），分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户

JDK应用：Comparator，Arrays.sort(list,Comparator)定义不同的比较算法策略

##### v、责任链

为请求创建了一个接收者对象的链(简单示意图)。这种模式对请求的发送者和接收者进行解耦。

职责链模式通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。

角色：

1) Handler : 抽象的处理者, 定义了一个处理请求的接口, 同时含义另外Handler
2) ConcreteHandlerA , B 是具体的处理者, 处理它自己负责的请求， 可以访问它的后继者(即下一个处理者), 如果
可以处理当前请求，则处理，否则就将该请求交个后继者去处理，从而形成一个职责链
3) Request ， 含义很多属性，表示一个请求

SpringMVC应用：HandlerExecutionChain